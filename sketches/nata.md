# NATA 设计稿

## 设计类图
Nata的设计围绕项目和测试用例展开,下面分别对图中出现的类进行解释
- Project<项目>. 项目代表你要测试的对象，他拥有名称，描述，封面等属性以及一个Apk的列表
- Apk<Android Application制品>. 一个Apk代表该项目的一次版本构建，它具有一个版本号以及相关联的一组测试计划的列表
- TestPlan<测试计划>. 测试计划代表你的测试意图，类似于单元测试中的测试集合的概念,测试计划有一个名称以及一组测试用例的列表。每个测试计划需要某个具体的测试技术相关联,由该测试技术提供相应的生成器和执行器.
- ModelDrivenTesting<模型驱动测试>. 对应用进行建模，刻画应用运行的有限自动机,模拟其运行过程.
- RandomTest<随机测试>. 对待测应用产生随机的测试流，通过大量随机的事件对系统进行压力测试，触发意想不到的bug.
- TestCase<测试用例>. 测试用例是最小的测试运行单位，通常为脚本形式，用于测试特定的应用功能，测试用例可以多次运行，生成一组测试结果的列表
- TestCaseGenerator<测试用例生成器>. 用于产生测试用例,可以通过多种技术生成.
- TestCaseRunner<测试用例运行器>. 用于运行测试用例，通常由具体的测试方法提供运行器
- DFSGenerator<基于DFS算法的测试用例生成器>. 使用DFS算法对应用进行建模，遍历测试并生成测试脚本.
- RecordGenerator<录制生成器>. 通过人工干预的方式录制测试用例，生成测试脚本.
- HumanGenerator<人工生成器>. 手工录入测试脚本.
- MonkeyGenerator<随机生成器>. 通过随机算法生成随机测试脚本.
- TestResult<测试结果>. 运行测试用例产生的测试结果,包括该测试脚本运行的起始时间和结束时间.
- TreeResult<树形图>. 测试结果的一种，一棵从根节点出发的应用遍历图
- LogResult<测试结果日志>. 测试过程中的日志输出
- BugResult<应用Bug列表>. 通过筛选应用的日志生成的出现错误的运行时列表


![](nata.png)

## 交互设计
### 主页项目列表
项目总览为应用的主视图，在这个界面中可以浏览所有待测的应用，每个应用表现为一张卡片，有一个自己的名称和描述，以及对应的一个具有辨识度的封面。
![](项目总览.png)

### 创建新项目
项目可以创建和更新,字段包括名称,描述和封面
![](创建新项目.png)

### 主页设备列表
设备列表管理所有连接的设备,上方为设备信息的总览，如设备的总数，可用的设备，忙设备的数量等。下方点击某个设备，可以在右方看到每个设备的具体信息.
![](设备列表.png)

### Apk管理界面
点击某个项目会进入到这个项目的管理界面，对应的有不同的应用版本,这个在Apk的列表中进行管理,包括Apk上传的日期，名称，版本号，描述，你可以下载对应的版本，也可以删除，不过删除的时候会将该版本关联的测试用例一并删除，请特别留意.
![](Apk管理.png)

### 运行列表
每个具体的应用版本都有一个测试计划的列表，每个测试计划都有一个测试用例的列表，每个测试用例可以被运行多次，形成一个运行列表，可以直观的看到其运行状态,开始的时间，参数，运行的设备，如果已经运行完可以查看其运行结果,如果正在运行可以查看其运行的过程
![](运行列表.png)

### 运行界面
测试用例运行时的观察界面，左侧可以实时观察到设备的运行情况,右侧可以对该测试用例进行控制以及观察到其实时运行的情况
![](运行界面.png)

### 脚本测试
对于DFS测试，录制测试，人工输入等各种可以生成测试脚本的测试技术我们统称为脚本测试，其界面为脚本的编辑界面,测试人员可以运行，编辑或删除该脚本
![](脚本测试.png)

### 选取分支
对于某个测试用例，如果具有生成树，那么我们可以通过选取某个分支来修改该分支脚本,可以看到该分支的概况以及运行时的截图等信息
![](选取分支.png)

### 编辑界面
编辑界面可以看到改脚本的具体分支节点,可以对该节点进行控制或者对该节点的脚本进行编辑
![](编辑.png)

### 弹出框
弹出框部分为系统中可能出现的弹出界面，包括选择版本，删除Apk，新建用例等
![](弹出框.png)

## 测试方法

### Monkey测试
[Monkey](https://developer.android.com/studio/test/monkey.html)是一个运行于物理设备或者模拟器上的伪随机事件生成工具。它可以自动地生成伪随机的用户事件，例如点击、触摸或者手势，同时还有一些系统事件。你可以使用Monkey对你开发的应用进行压力测试，虽然事件产生是随机的，但是该过程可以通过设置相同的随机种子来重现测试过程。

### DFS测试
DFS测试是使用深度优先算法，依次遍历应用中各个UI组件的测试技术。在Android应用测试中运用DFS算法，首先需要在图结构中定义State和Event这两个概念。如下图所示的深度优先的探索过程，节点s1~s5表示State，有向边e1和e3表示Event。e1驱动s1到s2，e3驱动s2到s5，由于s5已经探索过，所以e3并不在DFS树中。e2为s2状态探索完毕后回溯到s1的过程，并不为Event。  
![DFS测试结构图](DFS测试结构.png)

算法实现如下：  
![DFS算法](DFS算法.png)

算法中，具体的技术难点我们通过如下方案解决：   

- Android应用状态的判定。Android应用GUI状态繁多，需要一个有效的方式来识别和确认自动化测试过程中的状态。我们通过adb工具获取当前GUI状态中的Activity，使用UIautomator获取GUI中的组件结合，由这两个属性来确定GUI的状态。
- 路径爆炸的处理。在自动遍历复杂的应用时，极易出现路径爆炸的情况，导致遍历过程极为耗时。所以，需要一个有效的方法来处理这个问题。我们采用了近似的状态判定方法，对于两个状态相似的GUI，不再重复的进行探索，从而提高了遍历的效率。
- 驱动事件的获取。驱动应用状态变化的原因，是用户操作、系统事件和传感器事件等，有效地产生这些事件才能探索到尽可能多的GUI状态。我们利用了Java的reflect机制获取注册的监听器和UIautomator获取的xml识别组件类型，从而产生驱动事件。
- 回溯方法的实现。在DFS算法中，返回上一个状态的过程称为回溯，回溯可以保证应用状态的重现，从而继续遍历剩余的组件。我们采用试探性回溯，减少回溯过程的耗时。
- 结束状态的判定。能够使遍历过程在有限时间内停止，是整个算法有效性的保证，我们设定了探索的终止条件，保证遍历的机制的可行性。

最后会生成DFS搜索树状图，和Activity关系图：  
![DFS测试结果](DFS结果.png)

上图所示的是基于DFS的GUI探索过程生成的DFS树，同时给出了每一个Sate的详情，同时，从根节点至叶子节点可以构成一个测试用例，如图中(1)，方便测试者重现测试过程，或者进行回归测试。右图所示为通过测试分析得到的各个Activity之间的关系，通过分析Activity之间的关系，测试者可以判断应用跳转是否正确，判断整体设计概念是否符合用户需求。DFS测试技术可以应用于Android应用开发初期的集成测试，辅助测试者快速有效的发现错误，同时生成测试用例可用于应用的回归测试。

### Ape测试
Ape测试是在Monkey测试工具的基础上进行改进，使得产生的随机事件能够落在有效的组件上，减少无效的事件产生。
